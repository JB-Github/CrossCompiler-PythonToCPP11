
\input{header}


\title{ Einfacher? Crosscompiler von Python nach C++ }
\subject{Programmierpraktikum}
\author{Felix Helsch \\ Julian Buchhorn}
\date{\today}

\publishers{\parbox[b][8cm]{\textwidth}{\centering \textbf{Betreuer}\\Dr. Holger Arndt}}

\usepackage[version=3]{mhchem}
\usepackage{rotating}
\usepackage{booktabs}

\newcommand{\cc}[1]{\multicolumn{1}{c}{#1}} %Cell-Center
\newcommand{\C}[2]{\multicolumn{#1}{|c|}{#2}} %multiCol-wall
\newcommand{\mc}[2]{\multicolumn{#1}{c}{#2}} %multicol

\inlinecodestyle{python}
\lstset{ escapeinside= {\#(*} {*)} }
\lstset{
 rangeprefix= \#\\*,
 includerangemarker= false,
 texcl= false, %??
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\pagestyle{empty}
\maketitle
\tableofcontents

\lstlistoflistings
\listoffigures
%\clearpage
%\listoffigures
%\clearpage
%\listoftables
%\clearpage
%\lstlistoflistings

\clearpage
\pagestyle{fancy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Einleitung}

Im Rahmen eines Programmierpraktikums an der Bergischen Universität Wuppertal haben wir einen Compiler von Python zu C++ geschrieben. Dabei ging es in erster Linie darum, zu verstehen wie ein Compiler funktioniert und nicht darum einen vollständigen Compiler zu schreiben.

Als vorläufiges Ziel hatten wir uns gesetzt ein einfaches Testprogramm mit grundlegenden Syntaxelementen zu übersetzen (vgl. Lst. \ref{pyprog}).

\codefile[caption= Python Testprogramm für den Compiler, label=pyprog]{python}{program.py}

Das Ziel haben wir erreicht. Unser Compiler kann in seinem momentanen Zustand das Python Programm übersetzen und liefert das C++ Programm in Listing \ref{cppprog}. Dabei mussten wir, wie erwartet, einige Annahmen über das Programm machen, um die Übersetzung zu vereinfachen.

\codefile[caption= Vom Compiler erzeugtes C++ Programm, label=cppprog]{c++}{program.cpp}


In den folgenden Kapiteln werden wir erklären wie man den Compiler verwenden kann, welche Programme benötigt werden und welche Features der Compiler im Moment unterstützt. Zum Schluss werden wir noch kurz auf die Struktur des Codes eingehen, den wir geschrieben haben.

Für eine detailliertere Erklärung verweisen wir auf die Bachelorarbeit von Felix Helsch ..., in welcher die Erstellung des Compilers fortgeführt wird.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Verwendung}

Um ein Python Programm nach C++ zu compilieren, muss man nur das Main-Programm \ttt{py2cpp.py} aufrufen und dabei den Namen des zu übersetzenden Programms als Kommandozeilenparameter angeben. Das heißt, dass zum Beispiel unser Testprogramm \ttt{program.py} mit dem folgenden Konsolenbefehl übersetzt werden kann:
\begin{lstlisting}
python py2cpp.py program.py
\end{lstlisting}
Dafür muss man allerdings die benötigten Programme installiert haben (s. Kapitel \ref{progs}) und beachten, dass das zu übersetzende Programm nur die momentan unterstützten Features enthält (s. Kapitel \ref{features}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Installation} \label{progs}

Zuerst muss man das Archiv mit den Compilerdateien herunterladen \cite{py2cpp} und an einer beliebigen Stelle auspacken.
Außerdem müssen Python und C++ installiert sein (siehe nächster Abschnitt).
Innerhalb dieses Verzeichnisses kann der Compiler dann wie beschrieben aufgerufen werden, wenn sich die zu übersetzende Datei ebenfalls im selben Verzeichnis befindet.
Sonst sollte man entsprechend den absoluten Pfad angeben.


\subsection{Benötigte Programme}

Folgende Programme werden zur Verwendung des Compilers in jedem Fall benötigt, jeweils in der angegebenen Version oder einer neueren:

\begin{itemize}
\item \ttt{Python} 2.7
\begin{itemize}
\item \ttt{pandas} 0.15.2
\end{itemize}

\item \ttt{C++} 11
\item \texttt{Python-Runtime für Antlr} 4.4
\end{itemize}
%%

Die \ttt{Python-Runtime} ist in dem Compiler Archiv schon enthalten, braucht also nicht extra installiert werden. Falls man sie doch runterladen möchte findet man sie in der entsprechenden Sektion der \ttt{Antlr} Website \cite{pyruntime}.

\ttt{pandas} ist ein Package für Python welches der Compiler ebenfalls benötigt. Da \ttt{pandas} wiederum von den Packages \ttt{numpy}, \ttt{python-dateutil} und \ttt{pytz} abhängt, müssen diese ebenfalls installiert werden. Falls man diese Installationen nicht alle manuell durchführen will, bietet es sich hier an einen Package Manager zu benutzten (für Python unter Windows z.B. \ttt{Anaconda}). Für eine detaillierte Installationanleitung verweisen wir auf die Website von \ttt{pandas}  \cite{pandas}.

\subsection{Optionale Programme}

Die nachfolgenden Programme werden prinzipiell nur benötigt, wenn man die Grammatik \ttt{py.g4} neukompillieren möchte:
\begin{itemize}
\item \ttt{Antlr} 4.4

\begin{itemize}
\item \ttt{Java} 1.6
\end{itemize}
\end{itemize}

\ttt{Antlr} bietet allerdings auch noch zusätzliche Funktionen für die sich eine Installation lohnen kann. Zum Beispiel kann \ttt{Antlr} auch grafische Ansichten des Parsetrees erzeugen (s. Abbildung \ref{g:tree}), welche sehr nützlich sind zur Fehlersuche, oder einfach nur um die Struktur des Parsetrees besser zu verstehen. Außerdem kann die Grammatik dann nicht nur für \ttt{Python} kompilliert werden, sondern auch für die anderen Sprachen welche \ttt{Antlr}  unterstützt.


Da \ttt{Antlr} in \ttt{Java} geschrieben ist, benötigt es auch eine \ttt{Java} Installation. Insgesamt ist die Installation von \ttt{Antlr} etwas aufwändiger (insbesondere unter Windows), weswegen wir dazu noch eine ausführlichere Anleitung verfasst haben, welche sich in Abschnitt \ref{antlr:I} des Anhangs befindet. Insbesondere für die Installation unter Linux wollen wir aber auch auf die Anleitung auf der \ttt{Antlr} Website verweisen \cite{antlr}.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Features} \label{features}

\subsection{Unterstützte Syntaxelemente}

Sowohl Lexer als auch Parser unterstützen prinzipiell alle Syntaxelemente  von \ttt{Pathon} und funktionieren -- soweit getestetet -- mit allen Python Programmen. \todo{ richtig?? }

Bei der Codegenerierung werden bis jetzt nur die grundlegenden Synatxelemente untersutützt: Schleifen, if-elif-else, print stmt. Von den Schleifen wird insbesondere auch die Python for Schleife entwSchleife oder eine foreach Schleife übersetzt.

Für unser Testprogramm mussten wir wie bereits erwähnt einige Annahmen zur Vereinfachung treffen:

Alle Typdeklarationen haben wir als \ttt{double} angenommen. Dadurch sind einfach Funktionen wie in Zeile \ref{func} des Programms möglich. 
Insbesondere werden Variablendeklarationen noch nicht unterstützt. In Zeile \ref{array_decl} mussten wir deshalb einfach annehmen, das ein \ttt{array} deklariert wird.

Außerdem benötigt das Python Programm noch ein \ttt{if}~ \ttt{__name__=='__main__'} Block um beim Übersetzen zu erkennen, an welcher Stelle die \ttt{main} Funktion in C++ platziert werden soll.

 

\subsection{Fehlererkennung}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Codestruktur}

Schleißlich wollen wir in diesem Abschnitt noch kurz die Struktur unseres Codes erklären, damit man die Funktion des Compilers bei Interesse besser nachvollziehen kann.

In der \ttt{main} Datei \ttt{py2cpp.py} werden die verschiedenen Programmteile des Compilers aufgerufen:

\begin{description}

\item[\texttt{LexerLoop.lex(prog)}] Ruft den schleifenbasierten Lexer auf. Dieser Lexer hat den Vorteil das es einfacher ist an bestimmten Stellen Fehlermeldungen einzufügen, da das Programm Buchstabe für Buchstabe durchlaufen wird.

 Der Lexer welchen wir eigentlich verwendet haben, basiert auf regulären Ausdrücken und wird als Teil von \ttt{space2braces(prog)} aufgerufen.
 
\item[\ttt{space2braces(prog)}] Lext das Programm mit regulären Audrücken und findet aus der Einrückung Blockanfang und -ende herraus und fügt entsprechende Tokens ein (ebenso für Statement Ende). Gibt den Namen der so generierten Programmdatei zurück.

\item[\ttt{compile_grammar()}] Damit kann die Antlr Grammatik \ttt{py.g4} optional  auch diekt aus dem Wrapper neukompilliert werden. Beim kompillieren zu Python erzeugt Antlr die Dateien: \ttt{pyLexer.py}, \ttt{pyListener.py}, \ttt{pyParser.py}, \ttt{py.tokens} und  \ttt{pyLexer.tokens}.

\item[\ttt{pytree(prog_)}] Parst das umgewandelte Programm \ttt{prog_} mit dem aus der Antlr Grammatik generierten Parser. Anschließend wird der Parsetree mit dem Listener von Antlr durchlaufen und in unserem eigenen Parsetree gespeichert, welcher dann zurückgegeben wird.


\item[\ttt{AST.tofile(prog.replace('.py', '.cpp'))}] Durchläuft den Parsetree, wandelt die Python Syntax in C++ Syntax um und speichert das Ergebnis unter demselben Namen wie das Ausgangsprogramm, nur mit Endung \ttt{cpp} statt \ttt{py}.

\end{description}

\ttt{space2braces(...)} ist definiert in \ttt{space2braces.py} und befindet sich im Ordner \ttt{pylex} zusammen mit den restlichen Dateien, welche für den Lexer benötigt werden

\ttt{pytree(...)} ist definiert in \ttt{antlr2py.py} und ruft \ttt{parsetree.py} auf, wo die Datenstruktur für den Parsetree definiert ist, welche die Methode \ttt{tofile} besitzt. In \ttt{parsetree.py} befinden sich im Moment außerdem auch die Visitor Methoden für den Parsetree, das heißt dort findet die eigentliche Codegenerierung statt.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix
\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Installation und Verwendung von Antlr} 

\ttt{Antlr} ist prinzipiell ein Parser-Generator mit ähnlicher Syntax wie \ttt{Yacc} oder \ttt{Bison}. Der hauptsächliche Unterschied liegt darin, dass im Gegensatz zu \ttt{Yacc} ein recursiv-descent Parser erzeugt wird. Daraus ergibt sich der Vorteil, dass \ttt{Antlr} bessere Fehlermeldungen erzeugen kann. Ein Nachteil ist, dass keine indirekte Linksrekursion möglich ist.

Für eine Erklärung der Syntax verweisen wir auf die \ttt{Antlr} Homepage \cite{antlrH}, in diesem Kapitel werden nur die Installation beschrieben und die benötigten Kommandozeilenaufrufe für \ttt{Antlr} bzw. den erzeugten Parser.

\subsection{Installation} \label{antlr:I}

Um den Compiler ausführen zu können, muss Python in der Version 2.7 installiert sein. Außerdem werden die Python-Bibliotheken Numpy und Pandas, sowie deren Abhängigkeiten, benötigt. Am einfachsten ist es, hierfür einen Package-Manager wie zum Beispiel Anaconda zu installieren. \\ \\

Wenn die enthaltene Python Grammatik geändert werden soll und diese somit neu compiliert werden muss, ist die Installation etwas aufwändiger. Im Folgenden werden die Installationsschritte für Windows und Linux gezeigt.

\begin{enumerate}

\item Installation des Java Development Kit (SDK/JDK) in der Version 1.6 oder höher

\item Download des "`Complete ANTLR 4.4 Java binaries jar"'-Paketes (oder neuer) von der \href{http://www.antlr.org/download.html}{Download-Seite des ANTLR-Projektes}

\item Kopieren der heruntergeladenen Java-Bibliothek in den "`jre/lib/ext"'-Ordner des JDK (zum Beispiel: $"`C:\textbackslash Program Files (x86)\textbackslash Java\textbackslash jdk1.8.0\_25 \textbackslash jre\textbackslash lib\textbackslash ext"'$ \\ bzw. unter Linux: $/usr/lib64/jdk1.8.0\_25/jre/lib/ext/$)

\item Hinzufügen der jar-Datei zum Klassenpfad

\end{enumerate}


\subsection{Rekompilieren und grafische Synataxtree-Ansicht}



\begin{center}
 \includegraphics[width=0.8\linewidth]{Bilder/program_func_parse_tree2.png}
 \captionof{figure}{ Beispiel Parsetree } \label{g:tree}
\end{center}

%\input{Kapitel/Anhang}


\clearpage
\nocite{*}
\printbibliography

\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Code Schrift}
Text mit \ttt{Code} \ttt{Schrift} .

\subsubsection*{Inline Code}
\begin{lstlisting}[caption=CAP]
inline code test
\end{lstlisting}

\vspace{4ex}
\subsubsection*{Numerierter Inline Code}
\begin{nrcode}[caption=CCC, label=pynr, linerange={a-c, d-e}]
import math
#\*a
2
nr code test #(*\label{txtline}*)
4
5
#\*b
6
7
#\*c
8
9
#\*d
10
11
#\*e
12
\end{nrcode}

Referenz für Code \ref{pynr} Zeile \ref{txtline}.

Referenz für Code \ref{pycode} Zeile \ref{test_arith}.